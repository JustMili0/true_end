package net.justmili.trueend.procedures;

import net.minecraft.core.BlockPos;
import net.minecraft.core.registries.Registries;
import net.minecraft.resources.ResourceKey;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.LevelAccessor;
import net.minecraftforge.event.entity.player.AdvancementEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import net.justmili.trueend.TrueEndMod;
import net.justmili.trueend.init.TrueEndModGameRules;
import net.justmili.trueend.init.TrueEndModBlocks;
import net.justmili.trueend.variables.VariableMap;

import java.util.HashSet;
import java.util.Set;

import static net.justmili.trueend.TrueEndMod.MODID;

@Mod.EventBusSubscriber
public class CheckIfExitingEnd {
    // Dimension key for your custom dimension
    private static final ResourceKey<Level> BTD_DIMENSION = ResourceKey.create(
        Registries.DIMENSION, 
        new ResourceLocation(MODID, "beyond_the_dream")
    );

    // Keep track of which players have already been “beyond”
    private static final Set<ServerPlayer> PROCESSED = new HashSet<>();

    @SubscribeEvent
    public static void onAdvancement(AdvancementEvent event) {
        if (!event.getAdvancement().getId()
                .equals(new ResourceLocation(MODID, "stop_dreaming")))
            return;
        execute(event.getEntity().level(), event.getEntity());
    }

    public static void execute(LevelAccessor worldIn, Entity entity) {
        if (!(entity instanceof ServerPlayer player)) return;
        // Only run once per player
        if (PROCESSED.contains(player)) return;

        // Must be in Overworld
        if (player.level().dimension() != Level.OVERWORLD) return;

        // Per-player “beenBeyond” flag
        player.getCapability(VariableMap.PlayerVariablesProvider.PLAYER_VARIABLES_CAPABILITY)
            .ifPresent(vars -> {
                if (vars.isBeenBeyond()) return;
                // Mark processed so we don't re-enter the loop
                PROCESSED.add(player);

                // Record that this player has now been beyond
                vars.setBeenBeyond(true);

                // If configured to clear items, do so now
                boolean clear = VariableMap.GlobalVariables.get((ServerLevel)player.level()).isClearDreamItems();
                if (clear) {
                    player.getInventory().clearContent();
                    // Clear the flag so it's only used once
                    VariableMap.GlobalVariables.get((ServerLevel)player.level())
                        .setClearDreamItems(false);
                }

                // Teleport to BTD at the world spawn X,Z, with the same Y as spawn
                ServerLevel nextLevel = player.server.getLevel(BTD_DIMENSION);
                BlockPos spawn = ((ServerLevel)player.level()).getSharedSpawnPos();
                if (nextLevel != null) {
                    player.teleportTo(nextLevel,
                        spawn.getX() + 0.5, spawn.getY(), spawn.getZ() + 0.5,
                        player.getYRot(), player.getXRot());

                    // Now run your custom spawn finder in BTD and reposition if needed
                    BlockPos good = findIdealSpawnPoint(nextLevel, spawn);
                    if (good != null) {
                        player.teleportTo(nextLevel,
                            good.getX() + 0.5, good.getY(), good.getZ() + 0.5,
                            player.getYRot(), player.getXRot());
                    }

                    // Build home and send conversation a few ticks later
                    TrueEndMod.queueServerWork(45, () -> {
                        levelCommand(nextLevel, player, "function " + MODID + ":build_home");
                        sendFirstEntryConversation(player, nextLevel);
                    });
                }
            });
    }

    // Very basic ideal-spawn finder; adapt your original algorithm here
    private static BlockPos findIdealSpawnPoint(ServerLevel level, BlockPos center) {
        int radius = 24;
        for (int y = 75; y >= 64; y--) {
            for (int dx = -radius; dx <= radius; dx++) {
                for (int dz = -radius; dz <= radius; dz++) {
                    BlockPos pos = center.offset(dx, y - center.getY(), dz);
                    if (level.getBlockState(pos).is(TrueEndModBlocks.GRASS_BLOCK.get())
                        && level.getBiome(pos).is(new ResourceLocation(MODID, "nostalgic_meadow"))
                        && level.getBrightness(net.minecraft.world.level.LightLayer.SKY, pos.above()) >= 15
                        && isFlat(level, pos)) {
                        return pos.above();
                    }
                }
            }
        }
        return null;
    }

    private static boolean isFlat(ServerLevel level, BlockPos center) {
        int count = 0;
        int total = 0;
        int spread = 5;
        for (int dx = -spread; dx <= spread; dx++) {
            for (int dz = -spread; dz <= spread; dz++) {
                total++;
                BlockPos p = center.offset(dx, -1, dz);
                if (level.getBlockState(p).is(TrueEndModBlocks.GRASS_BLOCK.get())) count++;
                // no water at p, p.below(), p.below(2)
                if (level.getBlockState(p).is(net.minecraft.world.level.block.Blocks.WATER)
                 || level.getBlockState(p.below()).is(net.minecraft.world.level.block.Blocks.WATER)
                 || level.getBlockState(p.below(2)).is(net.minecraft.world.level.block.Blocks.WATER))
                    return false;
            }
        }
        return count >= (total * 7 / 8);
    }

    private static void sendFirstEntryConversation(ServerPlayer player, ServerLevel world) {
        String[] conversation = {
            "[\"\",{\"text\":\"\\n\"},{\"selector\":\"%s\",\"color\":\"dark_green\"},{\"text\":\"? You've awakened.\",\"color\":\"dark_green\"},{\"text\":\"\\n\"}]".formatted(player.getName().getString()),
            "{\"text\":\"So soon, thought it'd dream longer...\",\"color\":\"dark_aqua\"}",
            "[\"\",{\"text\":\"\\n\"},{\"text\":\"Well, it's beyond the dream now. The player, \",\"color\":\"dark_green\"},{\"selector\":\"%s\",\"color\":\"dark_green\"},{\"text\":\", woke up.\",\"color\":\"dark_green\"}]".formatted(player.getName().getString()),
            "[\"\",{\"text\":\"\\n\"},{\"text\":\"We left something for you in your home.\",\"color\":\"dark_aqua\"}]",
            "[\"\",{\"text\":\"\\n\"},{\"text\":\"Use it well.\",\"color\":\"dark_aqua\"}]",
            "[\"\",{\"text\":\"\\n\"},{\"text\":\"You may go back to the dream, a dream of a better world if you wish.\",\"color\":\"dark_green\"}]",
            "[\"\",{\"text\":\"\\n\"},{\"text\":\"We'll see you again soon, \",\"color\":\"dark_aqua\"},{\"selector\":\"%s\",\"color\":\"dark_aqua\"},{\"text\":\".\",\"color\":\"dark_aqua\"},{\"text\":\"\\n\"}]".formatted(player.getName().getString())
        };
        TrueEndMod.queueServerWork(45, () -> {
            TrueEndMod.sendTellrawMessagesWithCooldown(
                player, conversation,
                world.getGameRules().getRule(TrueEndModGameRules.BTD_CONVERSATION_MESSEGE_DELAY).get()
            );
        });
    }

    private static void levelCommand(ServerLevel lvl, ServerPlayer p, String cmd) {
        lvl.getServer().getCommands()
           .performPrefixedCommand(p.createCommandSourceStack().withSuppressedOutput(), cmd);
    }
}
